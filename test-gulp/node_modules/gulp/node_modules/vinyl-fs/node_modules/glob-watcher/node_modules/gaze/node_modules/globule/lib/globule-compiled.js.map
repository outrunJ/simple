{"version":3,"sources":["globule.js"],"names":[],"mappings":"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","file":"globule-compiled.js","sourcesContent":["/*\n * globule\n * https://github.com/cowboy/node-globule\n *\n * Copyright (c) 2013 \"Cowboy\" Ben Alman\n * Licensed under the MIT license.\n */\n\n'use strict';\n\nvar fs = require('fs');\nvar path = require('path');\n\nvar _ = require('lodash');\nvar glob = require('glob');\nvar minimatch = require('minimatch');\n\n// The module.\nvar globule = exports;\n\n// Process specified wildcard glob patterns or filenames against a\n// callback, excluding and uniquing files in the result set.\nfunction processPatterns(patterns, fn) {\n  return _.flatten(patterns).reduce(function(result, pattern) {\n    if (pattern.indexOf('!') === 0) {\n      // If the first character is ! all matches via this pattern should be\n      // removed from the result set.\n      pattern = pattern.slice(1);\n      return _.difference(result, fn(pattern));\n    } else {\n      // Otherwise, add all matching filepaths to the result set.\n      return _.union(result, fn(pattern));\n    }\n  }, []);\n}\n\n// Match a filepath or filepaths against one or more wildcard patterns. Returns\n// all matching filepaths. This behaves just like minimatch.match, but supports\n// any number of patterns.\nglobule.match = function(patterns, filepaths, options) {\n  // Return empty set if either patterns or filepaths was omitted.\n  if (patterns == null || filepaths == null) { return []; }\n  // Normalize patterns and filepaths to arrays.\n  if (!_.isArray(patterns)) { patterns = [patterns]; }\n  if (!_.isArray(filepaths)) { filepaths = [filepaths]; }\n  // Return empty set if there are no patterns or filepaths.\n  if (patterns.length === 0 || filepaths.length === 0) { return []; }\n  // Return all matching filepaths.\n  return processPatterns(patterns, function(pattern) {\n    return minimatch.match(filepaths, pattern, options || {});\n  });\n};\n\n// Match a filepath or filepaths against one or more wildcard patterns. Returns\n// true if any of the patterns match.\nglobule.isMatch = function() {\n  return globule.match.apply(null, arguments).length > 0;\n};\n\n// Return an array of all file paths that match the given wildcard patterns.\nglobule.find = function() {\n  var args = _.toArray(arguments);\n  // If the last argument is an options object, remove it from args.\n  var options = _.isPlainObject(args[args.length - 1]) ? args.pop() : {};\n  // Use the first argument if it's an Array, otherwise use all arguments.\n  var patterns = _.isArray(args[0]) ? args[0] : args;\n  // Return empty set if there are no patterns or filepaths.\n  if (patterns.length === 0) { return []; }\n  var srcBase = options.srcBase || options.cwd;\n  // Create glob-specific options object.\n  var globOptions = _.extend({}, options);\n  if (srcBase) {\n    globOptions.cwd = srcBase;\n  }\n  // Get all matching filepaths.\n  var matches = processPatterns(patterns, function(pattern) {\n    return glob.sync(pattern, globOptions);\n  });\n  // If srcBase and prefixBase were specified, prefix srcBase to matched paths.\n  if (srcBase && options.prefixBase) {\n    matches = matches.map(function(filepath) {\n      return path.join(srcBase, filepath);\n    });\n  }\n  // Filter result set?\n  if (options.filter) {\n    matches = matches.filter(function(filepath) {\n      // If srcBase was specified but prefixBase was NOT, prefix srcBase\n      // temporarily, for filtering.\n      if (srcBase && !options.prefixBase) {\n        filepath = path.join(srcBase, filepath);\n      }\n      try {\n        if (_.isFunction(options.filter)) {\n          return options.filter(filepath, options);\n        } else {\n          // If the file is of the right type and exists, this should work.\n          return fs.statSync(filepath)[options.filter]();\n        }\n      } catch(err) {\n        // Otherwise, it's probably not the right type.\n        return false;\n      }\n    });\n  }\n  return matches;\n};\n\nvar pathSeparatorRe = /[\\/\\\\]/g;\nvar extDotRe = {\n  first: /(\\.[^\\/]*)?$/,\n  last: /(\\.[^\\/\\.]*)?$/,\n};\nfunction rename(dest, options) {\n  // Flatten path?\n  if (options.flatten) {\n    dest = path.basename(dest);\n  }\n  // Change the extension?\n  if (options.ext) {\n    dest = dest.replace(extDotRe[options.extDot], options.ext);\n  }\n  // Join dest and destBase?\n  if (options.destBase) {\n    dest = path.join(options.destBase, dest);\n  }\n  return dest;\n}\n\n// Build a mapping of src-dest filepaths from the given set of filepaths.\nglobule.mapping = function(filepaths, options) {\n  // Return empty set if filepaths was omitted.\n  if (filepaths == null) { return []; }\n  options = _.defaults({}, options, {\n    extDot: 'first',\n    rename: rename,\n  });\n  var files = [];\n  var fileByDest = {};\n  // Find all files matching pattern, using passed-in options.\n  filepaths.forEach(function(src) {\n    // Generate destination filename.\n    var dest = options.rename(src, options);\n    // Prepend srcBase to all src paths.\n    if (options.srcBase) {\n      src = path.join(options.srcBase, src);\n    }\n    // Normalize filepaths to be unix-style.\n    dest = dest.replace(pathSeparatorRe, '/');\n    src = src.replace(pathSeparatorRe, '/');\n    // Map correct src path to dest path.\n    if (fileByDest[dest]) {\n      // If dest already exists, push this src onto that dest's src array.\n      fileByDest[dest].src.push(src);\n    } else {\n      // Otherwise create a new src-dest file mapping object.\n      files.push({\n        src: [src],\n        dest: dest,\n      });\n      // And store a reference for later use.\n      fileByDest[dest] = files[files.length - 1];\n    }\n  });\n  return files;\n};\n\n// Return a mapping of src-dest filepaths from files matching the given\n// wildcard patterns.\nglobule.findMapping = function(patterns, options) {\n  return globule.mapping(globule.find(patterns, options), options);\n};\n"]}