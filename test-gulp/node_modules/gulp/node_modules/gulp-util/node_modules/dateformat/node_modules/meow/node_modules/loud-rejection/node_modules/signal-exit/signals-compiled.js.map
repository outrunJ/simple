{"version":3,"sources":["signals.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;AAgBA,MAAM,CAAC,OAAO,GAAG,CACf,SAAS,EACT,SAAS,EACT,QAAQ,EACR,QAAQ,EACR,QAAQ,EACR,QAAQ,EACR,QAAQ,EACR,QAAQ,EACR,SAAS,EACT,SAAS,EACT,SAAS,EACT,SAAS,EACT,QAAQ,EACR,SAAS,EACT,SAAS,EACT,SAAS,EACT,WAAW,EACX,SAAS,EACT,SAAS,CACV,CAAA;;AAED,IAAI,OAAO,CAAC,QAAQ,KAAK,OAAO,EAAE;AAChC,QAAM,CAAC,OAAO,CAAC,IAAI,CACjB,OAAO,EACP,SAAS,EACT,QAAQ,EACR,WAAW,EACX,WAAW,CACZ,CAAA;CACF","file":"signals-compiled.js","sourcesContent":["// This is not the set of all possible signals.\n//\n// It IS, however, the set of all signals that trigger\n// an exit on either Linux or BSD systems.  Linux is a\n// superset of the signal names supported on BSD, and\n// the unknown signals just fail to register, so we can\n// catch that easily enough.\n//\n// Don't bother with SIGKILL.  It's uncatchable, which\n// means that we can't fire any callbacks anyway.\n//\n// If a user does happen to register a handler on a non-\n// fatal signal like SIGWINCH or something, and then\n// exit, it'll end up firing `process.emit('exit')`, so\n// the handler will be fired anyway.\n\nmodule.exports = [\n  'SIGABRT',\n  'SIGALRM',\n  'SIGBUS',\n  'SIGFPE',\n  'SIGHUP',\n  'SIGILL',\n  'SIGINT',\n  'SIGIOT',\n  'SIGPIPE',\n  'SIGPROF',\n  'SIGQUIT',\n  'SIGSEGV',\n  'SIGSYS',\n  'SIGTERM',\n  'SIGTRAP',\n  'SIGUSR2',\n  'SIGVTALRM',\n  'SIGXCPU',\n  'SIGXFSZ'\n]\n\nif (process.platform === 'linux') {\n  module.exports.push(\n    'SIGIO',\n    'SIGPOLL',\n    'SIGPWR',\n    'SIGSTKFLT',\n    'SIGUNUSED'\n  )\n}\n"]}