{"version":3,"sources":["index.js"],"names":[],"mappings":"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","file":"index-compiled.js","sourcesContent":["// Note: since nyc uses this module to output coverage, any lines\n// that are in the direct sync flow of nyc's outputCoverage are\n// ignored, since we can never get coverage for them.\nvar assert = require('assert')\nvar signals = require('./signals.js')\n\nvar EE = require('events')\n/* istanbul ignore if */\nif (typeof EE !== 'function') {\n  EE = EE.EventEmitter\n}\n\nvar emitter\nif (process.__signal_exit_emitter__) {\n  emitter = process.__signal_exit_emitter__\n} else {\n  emitter = process.__signal_exit_emitter__ = new EE()\n  emitter.count = 0\n  emitter.emitted = {}\n}\n\nmodule.exports = function (cb, opts) {\n  assert.equal(typeof cb, 'function', 'a callback must be provided for exit handler')\n\n  if (loaded === false) {\n    load()\n  }\n\n  var ev = 'exit'\n  if (opts && opts.alwaysLast) {\n    ev = 'afterexit'\n  }\n\n  var remove = function () {\n    emitter.removeListener(ev, cb)\n    if (emitter.listeners('exit').length === 0 &&\n        emitter.listeners('afterexit').length === 0) {\n      unload()\n    }\n  }\n  emitter.on(ev, cb)\n\n  return remove\n}\n\nmodule.exports.unload = unload\nfunction unload () {\n  if (!loaded) {\n    return\n  }\n  loaded = false\n\n  signals.forEach(function (sig) {\n    try {\n      process.removeListener(sig, sigListeners[sig])\n    } catch (er) {}\n  })\n  process.emit = originalProcessEmit\n  process.reallyExit = originalProcessReallyExit\n  emitter.count -= 1\n}\n\nfunction emit (event, code, signal) {\n  if (emitter.emitted[event]) {\n    return\n  }\n  emitter.emitted[event] = true\n  emitter.emit(event, code, signal)\n}\n\n// { <signal>: <listener fn>, ... }\nvar sigListeners = {}\nsignals.forEach(function (sig) {\n  sigListeners[sig] = function listener () {\n    // If there are no other listeners, an exit is coming!\n    // Simplest way: remove us and then re-send the signal.\n    // We know that this will kill the process, so we can\n    // safely emit now.\n    var listeners = process.listeners(sig)\n    if (listeners.length === emitter.count) {\n      unload()\n      emit('exit', null, sig)\n      /* istanbul ignore next */\n      emit('afterexit', null, sig)\n      /* istanbul ignore next */\n      process.kill(process.pid, sig)\n    }\n  }\n})\n\nmodule.exports.signals = function () {\n  return signals\n}\n\nmodule.exports.load = load\n\nvar loaded = false\n\nfunction load () {\n  if (loaded) {\n    return\n  }\n  loaded = true\n\n  // This is the number of onSignalExit's that are in play.\n  // It's important so that we can count the correct number of\n  // listeners on signals, and don't wait for the other one to\n  // handle it instead of us.\n  emitter.count += 1\n\n  signals = signals.filter(function (sig) {\n    try {\n      process.on(sig, sigListeners[sig])\n      return true\n    } catch (er) {\n      return false\n    }\n  })\n\n  process.emit = processEmit\n  process.reallyExit = processReallyExit\n}\n\nvar originalProcessReallyExit = process.reallyExit\nfunction processReallyExit (code) {\n  process.exitCode = code || 0\n  emit('exit', process.exitCode, null)\n  /* istanbul ignore next */\n  emit('afterexit', process.exitCode, null)\n  /* istanbul ignore next */\n  originalProcessReallyExit.call(process, process.exitCode)\n}\n\nvar originalProcessEmit = process.emit\nfunction processEmit (ev, arg) {\n  if (ev === 'exit') {\n    if (arg !== undefined) {\n      process.exitCode = arg\n    }\n    var ret = originalProcessEmit.apply(this, arguments)\n    emit('exit', process.exitCode, null)\n    /* istanbul ignore next */\n    emit('afterexit', process.exitCode, null)\n    return ret\n  } else {\n    return originalProcessEmit.apply(this, arguments)\n  }\n}\n"]}